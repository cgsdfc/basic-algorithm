#include <algorithm>
#include <cstdio>
using namespace std;

/*
大顶堆 数据结构

大顶堆可以实现优先队列，即一种以logn复杂度维护序列中的最大元，
并且支持插入和删除（类似队列操作）的数据结构。有些图论算法用优先队列可以加速。
在C语言环境下需要优先队列，或者专门考察堆排序/堆的题目中，要能够手写堆的算法。

堆的基础是完全二叉树：
1. 用数组保存，有效元素的下标为1--N，N是堆大小。所以数组的上界要大于N。
2. 叶子元素数量为 [N/2]，所以非叶子节点所在区间为[1, N/2]。
3. 根节点在1号。
4. 最后一个叶子节点在N号。
5. 判断一个节点i是否存在，用 i<=N。
6. 判断一个节点是否有孩子（即是否是非叶子节点），看它的左孩子是否存在，即
2*i<=N。

堆的操作：
1. 建堆。O(N)
2. 删除堆顶，即根节点。(logN)
3. 插入一个元素。 (logN)
4. 堆排序。(NlogN)

堆的要求：
1. 每一个节点，都是以该节点为根的子树中的最大元。
2. 根大于左孩子，也大于右孩子，而左孩子和右孩子的大小关系是不固定的。
3. 根节点是所有元素的最大元。
*/

// 数组上界。
#define MAXN 105

typedef int Elem;  // 堆的元素。

struct Heap {
    int N;  // 堆的元素个数。
    Elem data[MAXN];

    /*
    向下调整。low是要调整的元素，high是堆的边界（大小）。
    注意：DownAdjust 和 UpAdjust 有相同的参数，但是参数的意义不同。

    调整算法：
    1. 当前元素与两个孩子比大小，如果比孩子小，则和最大的孩子交换位置，
    从新的位置开始下一轮。
    2. 如果当前元素没有孩子，或者比孩子大，则调整结束。
    总体来说就是有两个跳出条件的while循环，因为当前元素是不断向下（叶子）
    移动的，所以叫做向下调整。

    向下调整的真正作用：
    现在有一个子树，假设左子树和右子树都满足堆的性质，但子树本身不满足，即根节点
    和孩子的关系不满足堆性质（这是前件）。对根调用一次向下调整后，整个子树就满足堆的性质。
    （这是后件）

    建堆：因为是自底向上建堆，所以每次调用向下调整前，其前件都满足（即右子树，右子树都是堆），
    所以完成后子树就是堆。以此类推，对根节点完成后，则整个树就是堆了。
    */
    void DownAdjust(int low, int high) {
        int i = low;
        int j = i * 2;       // i表示当前元素，j表示当前元素的左孩子。
        while (j <= high) {  // 只要当前元素的左孩子存在（即有孩子）。
            if (j + 1 <= high && data[j + 1] > data[j]) {
                // 如果存在右孩子（j+1），并且右孩子较大，就取右孩子的下标。
                // 这一步实际上是取两个孩子的最大者的下标，好跟当前元素i比较。
            }
            if (data[j] > data[i]) {
                // 当前元素i的孩子比i大，需要调整。
                swap(data[j], data[i]);
                i = j;      // 因为交换了位置，当前元素的位置变为j，令i=j，继续循环。
                j = 2 * i;  // j保持是i的左孩子。
            } else {
                // 出口2：当前元素i比孩子大，即满足堆的性质。
                break;
            }
        }
    }

    /*
    数据已经在堆中，但是并不符合堆的要求。
    建堆后数据满足堆的要求。

    注意建堆和删除元素对向下调整的使用的不同：
    1. 建堆，因为整个数组都不满足堆要求，所以要对所有非叶节点进行调整，
    具体来说是倒序的遍历这些非叶子节点，然后每个向下调整。

    2. 删除，因为去掉一个元素后，整个数组的堆性质只是局部被破坏，所以只需要对
    临时的根（也就是用队尾代替而来的根）进行向下调整。

    注意这个区别。
    */
    void CreateHeap() {
        // 倒序（自底向上）遍历非叶子节点，每个节点执行DownAdjust。
        for (int i = N / 2; i >= 1; --i) {
            DownAdjust(i, N);
        }
    }

    // 取堆顶，即最大元，即队首元素。
    Elem Top() {
        return data[1];
    }
    /*
    删除堆顶元素。一般是先取堆顶（Top），然后删除之，构成一个
    出队操作。

    删除算法：
    1. 用队尾元素覆盖队首元素，然后N减一。
    2. 对根进行一次向下调整。

    */
    void DeleteTop() {
        data[1] = data[N--];  // 注意N--，因为N是队尾，先取后减。
        DownAdjust(1, N);     // 对根向下调整。
    }

    /*
    向上调整。low是数组的下界，一般为1，high是待调整元素，一般为N，
    因为新插入元素一般在末尾。

    调整算法：
    1. 当前元素如果比父节点大，则当前元素和父节点交换位置，继续操作。
    2. 如果当前元素不存在父节点（即根），或者比父节点小，则算法结束。

    实际作用：假设一个子树满足堆的性质，除了它的一个叶子节点不满足。
    经过向上调整，整个子树重新满足堆的性质。
    */
    void UpAdjust(int low, int high) {
        int i = high;       // 当前元素。
        int j = i / 2;      // 当前元素的父节点。
        while (j >= low) {  // 只要父节点存在。
            if (data[i] > data[j]) {
                // 当前节点比其父节点大，说明当前节点要“上浮”，
                // 和父节点交换位置。
                swap(data[i], data[j]);
                // 继续向上调整。
                i = j;      // 当前元素的位置变为其原父节点的位置。
                j = i / 2;  // j保持为i的父节点。
            } else {
                break;  // 当前元素比父节点小，满足堆的性质，调整结束。
            }
        }
    }
    /*
    插入一个新元素。

    插入算法：
    1. 新元素插入到数组的末尾，N加一。
    2. 对队尾进行一次向上调整。
    */
    void Insert(int x) {
        data[++N] = x;
        UpAdjust(1, N);
    }

    /*
    将堆内元素原地排序，操作完成后数组内数据是递增的，
    因此不满足堆的要求。
    注意此操作会使数组不再是堆。

    算法：
    1. 因为堆顶是当前的最大元，所以只要不断进行删除操作，同时把当前堆顶按序输出，
    即可。
    2.
    此版本是原地操作，即把堆顶元素输出到数组的末尾，同时减少堆的大小，当堆大小为1
    时算法结束。
    3.
    具体来说，i从N到1，每次交换元素i和根，表示把根输出，然后堆的范围变为1--i-1，
    在此范围，对根进行向下调整（即删除操作的那个向下调整）。这就是原地堆排序。
    这里，i既是当前堆的大小，也指示当前堆的最后一个元素。在交换完成后，逻辑上堆的大小
    已经减小了1（因为堆顶已经删除了）（虽然N不变），所以当前大小就是i-1。
    当i=1时算法结束，因为一个元素的堆正好是有序序列的第一个元素。
    */
    void HeapSort() {
        CreateHeap();  // 先要建堆，否则以下步骤无意义。

        // 注意，DeleteTop并没有保存根，而是直接用队尾把根覆盖了，
        // 所以不能用DeleteTop实现排序，除非改它的实现。
        for (int i = N; i > 1; --i) {
            // 把当前最大元素输出到队尾的同时，把队尾放到队首，
            // 这样同时实现了保存和删除堆顶。
            swap(data[1], data[i]);
            // 现在i元素不属于堆了。
            DownAdjust(1, i - 1);  // 根不满足堆性质，用向下调整。
        }
    }
    /*
    总结：
    1. 根不满足堆性质，用向下调整。
    2. 叶子不满足堆性质，用向上调整。
    堆算法的代码量还是有一些的，但是只要记住算法的逻辑和实现上的细节，
    是不难的。
    */
};

/* run this program using the console pauser or add your own getch,
 * system("pause") or input loop */

int main(int argc, char** argv) {
    return 0;
}
