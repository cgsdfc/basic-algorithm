#include <cstdio>
#include <queue>
#include <vector>
using namespace std;

/*
利用队列实现的拓扑排序。
拓扑排序针对有向图，因为有向图的有向边代表了一种先后关系（前驱关系），而无向图的无向边代表的是联通的关系，
无向边是对称的，不存在谁先谁后，所以与拓扑排序无关。事实上，无向图如果看作有有向图的话，则每一条无向边都是一个环，
所以拓扑排序必然失败。

如果给定的图是DAG，即有向无环图，则拓扑排序成功；否则（有环）则拓扑排序失败。算法能够检测是否成功，并且在成功时
输出排序完成的序列。

拓扑排序定义的是偏序关系，即某些节点存在先后关系，而另外的节点则不存在先后关系；要使它成为全序关系，就需要增加第二标尺，
对于节点u，v，如果存在边u->v，则称u<v，即u要排在v前面，并且具有传递性，即如果u->v,v->s，则u<v，v<s，且u<s。

算法维护每个节点的当前入度来判断每个节点的前驱是否已经输出。一个节点当其入度为0时，说明前驱已经全部输出，该轮到此节点输出；
此节点输出后，要使每个它的后继的入度减一，表示这些节点的前驱输出了一个。

算法使用一个队列。队列里的节点满足其入度等于0，即当前可输出的节点，这些节点没有先后之分；如果需要第二标尺，可以使用优先队列。
每个节点输出后，按照上述规则更新其后继节点的入度。注意，更新后的入度不可能小于0，因为这就意味着这个节点的前驱被访问了多于1次，
也就是一个节点被访问多次，这是不可能的，因为入度从非负数减少到0，并且不增加，则只可能有1次减到0的机会，所以一个节点的入队次数为0或者1次。 

如果存在环，则显然，环上的任何节点的入度都不可能减到0，所以环上的任何节点都不可能输出。 

算法复杂度：O(E+V)，每个节点入队最多一次，出队最多一次，每次出队要访问全部邻居。 
*/

#define MAXN 505 // 节点数。

int in[MAXN]; // 输入图的时候可以记录每个节点的入度。 
int N;
vector<int> Adj[MAXN];

bool TopoSort() {
	queue<int> Q;
	int num=0; // 拓扑序列的节点数，判断是否排序成功。
	// 队列初始时，为入度=0的节点。
	for (int v=0;v<N;++v) {
		if (!in[v]) {
			Q.push(v);
		}
	}
	// 主循环
	while (!Q.empty()) {
		int u=Q.front();
		Q.pop();
		printf("%d\n", u); // 输出当前元素。
		++num; // 计数拓扑序列的元素个数。
		// 更新后继节点的入度。
		for (int i=0;i<Adj[u].size();++i) {
			int v=Adj[u][i];
			--in[v];
			if (!in[v]) {
				// 可以输出了。
				Q.push(v); 
			}
		} 
	}
	return num==N;
}

/* run this program using the console pauser or add your own getch, system("pause") or input loop */

int main(int argc, char** argv) {
	return 0;
}
