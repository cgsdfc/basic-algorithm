#include <stdio.h>
#include <stdlib.h>

/* run this program using the console pauser or add your own getch,
 * system("pause") or input loop */

/*
求一个位上总共出现了多少1，先看它的上位，比如十位的上位是百位。
现以求十位上有多少1为例子：
有数字321.

为求十位上的1，先除以100，321/100=3，因为十位的1每过100则增加10个。
这就算了1--100，101--200，201--300，这些段的十位的1.
所以就是3*10=30个，再看模100，即321%100=21=X，来看从301到321，十位有多少1.
判断条件是：
1. X大于等于20，则有10个1.
2. X大于等于10，小于等于19，则有X%10 + 1个1.
3. X小于10，则0个。

上述特殊情况推广到其他位时，常数相应的变化。

算法：先求低位的1，个十百千万。
总结：这是属于找规律的题目，找到规律了就不难了，关键要快速的找规律，
否则会耗费很多时间。技巧是先研究一种特殊情况，比如这里的十位的1，然后
推广到一般情况，比如任意位置的1.

规律：
1. 个位的1，每过10个数增加一个，即每10个数里有一个个位的1.
2. 十位的1，在10--19区间共10个，每过100个数增加10个，即每100个数里有10个十位的1.
3. 百位的1，以此类推。
在计算每一位上的1时，先算整的，再算散的，即比如十位，先算有多少整10个1，再计算不总100
的数字里有多少1，按照10--20区间的划分，即可。

*/

int Count(int N) {
  int ans = 0;
  int p2 = 1;
  // 用来控制循环
  int K = N;

  while (K) {
    // 求个位，先看十位，求十位，先看百位。
    int p = p2 * 10;
    int q = N / p;
    int r = N % p;

    ans += q * p2;
    // >=20，则10--19全都有。
    if (r >= 2 * p2) {
      ans += p2;
      // 10到19之间，则
    } else if (p2 <= r) {
      ans += r % p2 + 1;
      // 小于10，则什么都没有。
    } else {
      ans += 0;
    }

    p2 *= 10;
    K /= 10;
  }
  return ans;
}

int main(int argc, char *argv[]) {
  int N;
  int ans;
  /*
  复杂度时N的10进制位数的线性。
  */
  scanf("%d", &N);
  ans = Count(N);
  printf("%d\n", ans);

  return 0;
}
